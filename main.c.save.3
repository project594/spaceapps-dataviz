#include <stdio.h>
#include <stdlib.h>
#include <raylib.h>
#include <math.h>

const double toDegrees = 180.0 / M_PI;
const int scale = 2000;

typedef struct Point {
	float x;
	float y;
} Point;

typedef struct Sprite {
	Texture2D texture;
	Rectangle dest_rect;
} Sprite;

typedef struct PID_Controller {
    double Gain;
    double Kp;
    double Ki;
    double Kd;
    double setpoint;
    double integral_sum;
    double prev_error;
    double output_min;
    double output_max;
} PID_Controller;

typedef struct phys_Shaft {
	double x;
	double y;
	double angle;
	double radius;
	double inertia;
	double omega;
	double accel;
	double torque;
	double Mu;
} phys_Shaft;

typedef struct cylinder {
	double bore;
	double stroke;
	double rodLength;
	double pressure;
} cylinder;

typedef struct piston {
	double position; // position relative to tdc
	double velocity;
	double area;
	double inForce;
	double outForce;
} piston;

typedef struct head {
	double intakePressure; 
	double headVolume;
	double exhaustDisplacement;
	double intakeDisplacement;
	double intakeVRadius;
	double intakeSRadius;
	double exhaustVRadius;
	double exhaustSRadius;
} head;

void Initialize(){
	SetTargetFPS(2500);
}

float getForceFromP(cylinder* cyl) {\
	double r = cyl->bore / 2;
	double f = cyl->pressure * (M_PI * (r * r));	
	return f;
}

float PID_Update(PID_Controller* pid, float process_variable, double dt) {
    float error = pid->setpoint - process_variable;

    // Proportional term
    float p_term = pid->Kp * error;

    // Integral term
    pid->integral_sum += error * dt;
    float i_term = pid->Ki * pid->integral_sum;

    // Derivative term
    float derivative = (error - pid->prev_error) / dt;
    float d_term = pid->Kd * derivative;

    // Total output
    float output = (p_term + i_term + d_term) * pid->Gain;

    // Apply output limits
    if (output > pid->output_max) {
        output = pid->output_max;
    } else if (output < pid->output_min) {
        output = pid->output_min;
    }

    pid->prev_error = error;
    return output;
}

void drawShaft(phys_Shaft* shaft){
	const Vector2 center = { shaft->x, shaft->y };
	DrawCircle(shaft->x, shaft->y, shaft->radius * scale, RAYWHITE);
	DrawCircleSector(
			center, 
			shaft->radius * scale, 
			shaft->angle * toDegrees + 10, 
			shaft->angle * toDegrees - 10, 
			3, 
			GRAY
		);
}

void drawPoint(Point* point){
	DrawCircle(point->x, point->y, 5, BLACK);
}

void updShaftTorque(phys_Shaft* shaft,double dt){
	shaft->accel = shaft->torque / shaft->inertia;
	shaft->omega += shaft->accel * dt;
	shaft->omega -= shaft->omega * 30.0 * dt;
	shaft->angle += shaft->omega * dt;
	if (isnan(shaft->omega)){
		shaft->omega = 0;
	}
	if (isnan(shaft->angle)){
		shaft->angle = 0;
	}
}


void updShaftSpeed(phys_Shaft* shaft, const float dt) {
	

}

double calcEffectiveRodLength(double length, double radius, double theta){
	double rcos = radius * cos(theta);
	return sqrt(length * length - (rcos * rcos));
}

double getTcsFromFp(double fp, double theta, double L, double R){
	double n = L/R;
	double Tcs = fp * R * (cos(theta) + (sin(2 * theta))/(2 * sqrt(n * n - sin(theta) * sin(theta))));
	return Tcs;
}

int inputx = 0;
int inputy = 0;

void control(){
	if (IsKeyDown(KEY_D)){
		inputx = 1;
	}
	else if (IsKeyDown(KEY_A)){
		inputx = -1;
	}
	else if (IsKeyDown(KEY_W)){
		inputy = 1;
	}
	else if (IsKeyDown(KEY_S)){
		inputy = -1;
	}
	else {
		inputy = 0;
		inputx = 0;
	}
}



int main(){
	const int width = 600;
	const int height = 400;
	float preverror = 0.0;	
	
	
	phys_Shaft crankshaft = (phys_Shaft){
		.x = 		300,
		.y = 		300,

		.angle = 	M_PI,
		.radius = 	0.045,
		.inertia = 	0.9,
		.omega = 	0.0,
		.accel = 	0.0,
		.Mu = 		0.01,
		.torque = 	0.0,
	};
	phys_Shaft *crankshaftPtr = &crankshaft;

	cylinder cyl_1 = (cylinder){
		.bore = 	0.084,		// diameter
		.stroke = 	0.09,		// stroke must be 2 * crankshaft radius
	/	.rodLength = 	0.14435,	// must be larger than stroke
		.pressure = 	3000000.0,
	};
	cylinder *cyl_1Ptr = &cyl_1;
	
	head head_1 = (head){
		.intakePressure = 	101325.0, 	// 1 atm = 101325 Pa
		.headVolume = 		0.00084, 	// temp, in m^3
		.exhaustDisplacement = 	0.0,  		// valve opening in m
		.intakeDisplacement = 	0.0,
		.intakeVRadius = 	0.0165,		// valve radius
		.intakeSRadius = 	0.015,		// seat radius
		.exhaustVRadius = 	0.0145,
		.exhaustSRadius = 	0.0135,		
	};

	piston piston_1 = (piston){
		.position = 0,
		.velocity = 0,
		.area = (cyl_1Ptr->bore / 2) * (cyl_1Ptr->bore / 2) * M_PI,
		.inForce = 0,
		.outForce = 0,
	}
		
	Point point_a = (Point){
		.x = 0,
		.y = 0,
	};
	Point *point_aPtr = &point_a;

	Point point_b = (Point){
		.x = 0,
		.y = 0,
	};
	Point *point_bPtr = &point_b;
	
	PID_Controller pid = (PID_Controller){
		.Gain = 10.0,
		.Kp = 0.1,
   		.Ki = 0.0,
   		.Kd = 0.08,
   		.setpoint = 80.0,
   		.integral_sum = 0.0,
   		.prev_error = 0.0,
   		.output_min = -30.0,
    		.output_max = 30.0,
	};
	PID_Controller *pidPtr = &pid;

	InitWindow(width, height, "great");	
	Initialize();

	while(!WindowShouldClose()) {
		double dt = GetFrameTime();
		double pidOutput = PID_Update(pidPtr, crankshaftPtr->angle, dt);
		
		if (isnan(pidOutput)){
			pidOutput = 0;
		}
		control();
	//	crankshaftPtr->torque = pidOutput;
		//crankshaftPtr->torque = getTcsFromFp(100000.0 * (sin(crankshaftPtr->angle / 2) * sin(crankshaftPtr->angle / 2 )),crankshaftPtr->angle,cyl_1Ptr->rodLength,crankshaftPtr->radius) + 1000.0 * inputx;

		
		crankshaftPtr->torque = getTcsFromFp(getForceFromP(cyl_1Ptr), crankshaftPtr->angle, cyl_1Ptr->rodLength, crankshaftPtr->radius) + 1000 * inputx;
		
		updShaftTorque(crankshaftPtr, dt);
		
		point_aPtr->x = crankshaftPtr->radius * scale * cos(crankshaftPtr->angle) + crankshaftPtr->x;
		point_aPtr->y = crankshaftPtr->radius * scale * sin(crankshaftPtr->angle) + crankshaftPtr->y;
		
		point_bPtr->x = crankshaftPtr->x;
		point_bPtr->y = crankshaftPtr->y - calcEffectiveRodLength(cyl_1Ptr->rodLength * scale, crankshaftPtr->radius * scale, crankshaftPtr->angle) + crankshaftPtr->radius * scale * sin(crankshaftPtr->angle);
		
		preverror = (M_PI - crankshaftPtr->angle);


		BeginDrawing();

		// draw stuff
		ClearBackground(SKYBLUE);
		DrawText(TextFormat("dt: %02.09f ms", dt), 10, 10, 10, BLACK);
//		DrawText(TextFormat("theta: %02.09f ms", (crankshaftPtr->omega * 0.159155 * 60)), 10, 30, 20, GRAY);
DrawText(TextFormat("theta: %02.09f ms", (crankshaftPtr->angle)), 10, 30, 20, GRAY);
		DrawText(TextFormat("Fp: %02.09f n", cos(crankshaftPtr->angle / 2) * cos(crankshaftPtr->angle / 2)), 10, 70, 20, GRAY);
		// draw crankshaft
		drawShaft(&crankshaft);

		// draw points
		drawPoint(point_aPtr);
		drawPoint(point_bPtr);
		DrawLine(point_aPtr->x, point_aPtr->y, point_bPtr->x, point_bPtr->y, BLACK);
		EndDrawing();
	}
	

	CloseWindow();


	return 0; 
}
